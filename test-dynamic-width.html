<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŠ¨æ€çº¿å®½æµ‹è¯•</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2em;
        }
        
        .test-info {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 25px;
        }
        
        .test-info h3 {
            margin: 0 0 10px 0;
            font-size: 1.2em;
        }
        
        .canvas-container {
            position: relative;
            margin: 25px 0;
            border: 3px solid #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            background: #fafafa;
        }
        
        canvas {
            display: block;
            cursor: crosshair;
            background: white;
        }
        
        .controls {
            margin: 25px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        label {
            font-weight: bold;
            color: #555;
            font-size: 14px;
        }
        
        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
        }
        
        .value-display {
            min-width: 60px;
            text-align: center;
            background: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
            font-weight: bold;
            color: #333;
        }
        
        button {
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .status {
            margin: 20px 0;
            padding: 15px;
            background: #e8f5e8;
            border-radius: 6px;
            font-family: monospace;
            border-left: 4px solid #4caf50;
            font-size: 13px;
        }
        
        .test-instructions {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
        }
        
        .test-instructions h4 {
            margin: 0 0 10px 0;
            color: #856404;
        }
        
        .test-instructions ul {
            margin: 0;
            padding-left: 20px;
            color: #856404;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ–Œï¸ åŠ¨æ€çº¿å®½æµ‹è¯•</h1>
        
        <div class="test-info">
            <h3>ğŸ¯ æµ‹è¯•ç›®æ ‡</h3>
            <p>éªŒè¯ä¿®å¤åçš„è¿ç¬”æ•ˆæœï¼šæ—¢ä¿æŒçº¿æ¡è¿ç»­æ€§ï¼Œåˆæ¢å¤åŠ¨æ€çº¿å®½å˜åŒ–åŠŸèƒ½</p>
        </div>
        
        <div class="test-instructions">
            <h4>ğŸ“‹ æµ‹è¯•è¯´æ˜</h4>
            <ul>
                <li><strong>æ…¢é€Ÿç»˜åˆ¶</strong>ï¼šåº”è¯¥æ˜¾ç¤ºè¾ƒç²—çš„çº¿æ¡</li>
                <li><strong>å¿«é€Ÿç»˜åˆ¶</strong>ï¼šåº”è¯¥æ˜¾ç¤ºè¾ƒç»†çš„çº¿æ¡</li>
                <li><strong>å‹åŠ›å˜åŒ–</strong>ï¼šé¼ æ ‡æŒ‰ä¸‹æ·±åº¦å½±å“çº¿å®½ï¼ˆæ¨¡æ‹Ÿå‹åŠ›ï¼‰</li>
                <li><strong>è¿ç»­æ€§</strong>ï¼šçº¿æ¡åº”è¯¥å®Œå…¨è¿ç»­ï¼Œæ— ç©ºéš™</li>
                <li><strong>å¹³æ»‘åº¦</strong>ï¼šå¯ç”¨è´å¡å°”å¹³æ»‘æ—¶çº¿æ¡åº”è¯¥æ›´æµç•…</li>
            </ul>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>åŸºç¡€çº¿å®½</label>
                <div class="control-row">
                    <input type="range" id="baseSize" min="2" max="30" value="8">
                    <div class="value-display" id="baseSizeValue">8</div>
                </div>
            </div>
            
            <div class="control-group">
                <label>æœ€å¤§çº¿å®½</label>
                <div class="control-row">
                    <input type="range" id="maxWidth" min="5" max="50" value="20">
                    <div class="value-display" id="maxWidthValue">20</div>
                </div>
            </div>
            
            <div class="control-group">
                <label>å‹åŠ›æ•æ„Ÿåº¦</label>
                <div class="control-row">
                    <input type="range" id="pressureSensitivity" min="0" max="100" value="80">
                    <div class="value-display" id="pressureSensitivityValue">80%</div>
                </div>
            </div>
            
            <div class="control-group">
                <label>é€Ÿåº¦æ•æ„Ÿåº¦</label>
                <div class="control-row">
                    <input type="range" id="velocitySensitivity" min="0" max="100" value="60">
                    <div class="value-display" id="velocitySensitivityValue">60%</div>
                </div>
            </div>
            
            <div class="control-group">
                <label>å¹³æ»‘åº¦</label>
                <div class="control-row">
                    <input type="range" id="smoothing" min="0" max="100" value="30">
                    <div class="value-display" id="smoothingValue">30%</div>
                </div>
            </div>
            
            <div class="control-group">
                <label style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="enableBezier" checked>
                    è´å¡å°”å¹³æ»‘
                </label>
                <label style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="showDebug">
                    æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
                </label>
            </div>
            
            <button onclick="clearCanvas()">æ¸…é™¤ç”»å¸ƒ</button>
            <button onclick="runAutoTest()">è‡ªåŠ¨æµ‹è¯•</button>
        </div>
        
        <div class="canvas-container">
            <canvas id="testCanvas" width="900" height="600"></canvas>
        </div>
        
        <div class="status" id="status">
            å‡†å¤‡å°±ç»ª - å¼€å§‹æµ‹è¯•åŠ¨æ€çº¿å®½æ•ˆæœ
        </div>
    </div>

    <script>
        class DynamicWidthTest {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.isDrawing = false;
                this.currentStroke = [];
                this.lastPoint = null;
                this.lastTimestamp = 0;
                this.debugMode = false;
                
                this.setupEventListeners();
                this.setupControls();
                
                // è®¾ç½®é»˜è®¤æ ·å¼
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.globalCompositeOperation = 'source-over';
                
                this.updateStatus('æµ‹è¯•ç¯å¢ƒå·²åˆå§‹åŒ–');
            }
            
            setupEventListeners() {
                // é¼ æ ‡äº‹ä»¶
                this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                this.canvas.addEventListener('mousemove', (e) => this.draw(e));
                this.canvas.addEventListener('mouseup', () => this.stopDrawing());
                this.canvas.addEventListener('mouseout', () => this.stopDrawing());
                
                // è§¦æ‘¸äº‹ä»¶
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.startDrawing(e.touches[0]);
                });
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.draw(e.touches[0]);
                });
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.stopDrawing();
                });
            }
            
            setupControls() {
                const controls = [
                    'baseSize', 'maxWidth', 'pressureSensitivity', 
                    'velocitySensitivity', 'smoothing'
                ];
                
                controls.forEach(id => {
                    const slider = document.getElementById(id);
                    const valueSpan = document.getElementById(id + 'Value');
                    
                    slider.addEventListener('input', () => {
                        let value = slider.value;
                        if (id.includes('Sensitivity') || id === 'smoothing') {
                            value += '%';
                        }
                        valueSpan.textContent = value;
                    });
                });
                
                document.getElementById('showDebug').addEventListener('change', (e) => {
                    this.debugMode = e.target.checked;
                });
            }
            
            getEventPoint(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (this.canvas.width / rect.width);
                const y = (e.clientY - rect.top) * (this.canvas.height / rect.height);
                
                // æ¨¡æ‹Ÿå‹åŠ›ï¼ˆæ ¹æ®é¼ æ ‡ç§»åŠ¨é€Ÿåº¦ï¼‰
                let pressure = 0.5;
                if (this.lastPoint) {
                    const dx = x - this.lastPoint.x;
                    const dy = y - this.lastPoint.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    pressure = Math.max(0.1, Math.min(1.0, 1.0 - distance / 50));
                }
                
                return {
                    x, y,
                    pressure: e.pressure || pressure,
                    timestamp: Date.now()
                };
            }
            
            startDrawing(e) {
                this.isDrawing = true;
                const point = this.getEventPoint(e);
                this.currentStroke = [point];
                this.lastPoint = point;
                this.lastTimestamp = point.timestamp;
                
                this.updateStatus(`å¼€å§‹ç»˜åˆ¶ - åæ ‡: (${Math.round(point.x)}, ${Math.round(point.y)}), å‹åŠ›: ${point.pressure.toFixed(2)}`);
            }
            
            draw(e) {
                if (!this.isDrawing) return;
                
                const point = this.getEventPoint(e);
                this.currentStroke.push(point);
                
                // è®¡ç®—è¿ç¬”å‚æ•°
                this.calculateStrokeParameters();
                
                // ç»˜åˆ¶åŠ¨æ€çº¿å®½æ•ˆæœ
                this.drawDynamicStroke();
                
                this.lastPoint = point;
                
                if (this.debugMode) {
                    const lastPoint = this.currentStroke[this.currentStroke.length - 1];
                    this.updateStatus(`ç»˜åˆ¶ä¸­ - ç‚¹æ•°: ${this.currentStroke.length}, çº¿å®½: ${lastPoint.dynamicWidth?.toFixed(1)}, é€Ÿåº¦: ${lastPoint.velocity?.toFixed(2)}`);
                }
            }
            
            stopDrawing() {
                if (!this.isDrawing) return;
                
                this.isDrawing = false;
                const avgWidth = this.currentStroke.reduce((sum, p) => sum + (p.dynamicWidth || 0), 0) / this.currentStroke.length;
                this.updateStatus(`ç»˜åˆ¶å®Œæˆ - æ€»ç‚¹æ•°: ${this.currentStroke.length}, å¹³å‡çº¿å®½: ${avgWidth.toFixed(1)}`);
            }
            
            calculateStrokeParameters() {
                if (this.currentStroke.length < 2) return;
                
                const baseSize = parseInt(document.getElementById('baseSize').value);
                const maxWidth = parseInt(document.getElementById('maxWidth').value);
                const pressureSensitivity = document.getElementById('pressureSensitivity').value / 100;
                const velocitySensitivity = document.getElementById('velocitySensitivity').value / 100;
                
                for (let i = 0; i < this.currentStroke.length; i++) {
                    const point = this.currentStroke[i];
                    
                    // è®¡ç®—è·ç¦»å’Œé€Ÿåº¦
                    if (i > 0) {
                        const prev = this.currentStroke[i - 1];
                        const dx = point.x - prev.x;
                        const dy = point.y - prev.y;
                        point.distance = Math.sqrt(dx * dx + dy * dy);
                        
                        const timeDiff = point.timestamp - prev.timestamp;
                        point.velocity = timeDiff > 0 ? point.distance / timeDiff : 0;
                    } else {
                        point.distance = 0;
                        point.velocity = 0;
                    }
                    
                    // è®¡ç®—åŠ¨æ€çº¿å®½
                    let width = baseSize;
                    
                    // å‹åŠ›å½±å“ï¼ˆå‹åŠ›å¤§çº¿å®½å¤§ï¼‰
                    const pressureFactor = 0.5 + (point.pressure - 0.5) * pressureSensitivity;
                    width *= pressureFactor;
                    
                    // é€Ÿåº¦å½±å“ï¼ˆé€Ÿåº¦å¿«çº¿å®½å°ï¼‰
                    const velocityFactor = Math.max(0.3, 1 - point.velocity * velocitySensitivity * 0.02);
                    width *= velocityFactor;
                    
                    point.dynamicWidth = Math.max(1, Math.min(maxWidth, width));
                }
            }
            
            drawDynamicStroke() {
                if (this.currentStroke.length < 2) return;
                
                const enableBezier = document.getElementById('enableBezier').checked;
                const smoothing = document.getElementById('smoothing').value / 100;
                
                if (enableBezier && this.currentStroke.length > 3) {
                    this.drawBezierStroke(smoothing);
                } else {
                    this.drawSimpleStroke();
                }
            }
            
            drawBezierStroke(smoothingFactor) {
                const points = this.getSmoothPoints(smoothingFactor);
                this.drawVariableWidthPath(points, true);
            }
            
            drawSimpleStroke() {
                this.drawVariableWidthPath(this.currentStroke, false);
            }
            
            drawVariableWidthPath(points, isSmooth) {
                if (points.length < 2) return;
                
                // ä½¿ç”¨åˆ†æ®µç»˜åˆ¶æ¥å®ç°åŠ¨æ€çº¿å®½
                for (let i = 0; i < points.length - 1; i++) {
                    const current = points[i];
                    const next = points[i + 1];
                    
                    const currentWidth = current.dynamicWidth || 5;
                    const nextWidth = next.dynamicWidth || 5;
                    const distance = Math.sqrt(
                        Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2)
                    );
                    
                    // æ ¹æ®çº¿å®½å˜åŒ–å’Œè·ç¦»å†³å®šåˆ†æ®µæ•°
                    const widthDiff = Math.abs(nextWidth - currentWidth);
                    const segments = Math.max(1, Math.min(8, 
                        Math.ceil(distance / 4) + Math.ceil(widthDiff * 2)
                    ));
                    
                    // ç»˜åˆ¶åˆ†æ®µ
                    for (let j = 0; j < segments; j++) {
                        const t1 = j / segments;
                        const t2 = (j + 1) / segments;
                        const t = (t1 + t2) / 2;
                        
                        // æ’å€¼çº¿å®½
                        const segmentWidth = currentWidth + (nextWidth - currentWidth) * t;
                        
                        // æ’å€¼ä½ç½®
                        const startX = current.x + (next.x - current.x) * t1;
                        const startY = current.y + (next.y - current.y) * t1;
                        const endX = current.x + (next.x - current.x) * t2;
                        const endY = current.y + (next.y - current.y) * t2;
                        
                        // ç»˜åˆ¶æ®µ
                        this.ctx.lineWidth = segmentWidth;
                        this.ctx.beginPath();
                        this.ctx.moveTo(startX, startY);
                        this.ctx.lineTo(endX, endY);
                        this.ctx.stroke();
                    }
                }
            }
            
            getSmoothPoints(smoothingFactor) {
                const points = this.currentStroke;
                if (points.length < 3) return points;
                
                const smoothPoints = [];
                
                for (let i = 0; i < points.length; i++) {
                    const point = { ...points[i] };
                    
                    if (i > 0 && i < points.length - 1) {
                        const prev = points[i - 1];
                        const next = points[i + 1];
                        
                        // è®¡ç®—æ§åˆ¶ç‚¹
                        const d1 = Math.sqrt(Math.pow(point.x - prev.x, 2) + Math.pow(point.y - prev.y, 2));
                        const d2 = Math.sqrt(Math.pow(next.x - point.x, 2) + Math.pow(next.y - point.y, 2));
                        
                        const fa = smoothingFactor * d1 / (d1 + d2);
                        const fb = smoothingFactor * d2 / (d1 + d2);
                        
                        const p1x = point.x - fa * (next.x - prev.x);
                        const p1y = point.y - fa * (next.y - prev.y);
                        const p2x = point.x + fb * (next.x - prev.x);
                        const p2y = point.y + fb * (next.y - prev.y);
                        
                        point.cp1 = { x: p1x, y: p1y };
                        point.cp2 = { x: p2x, y: p2y };
                    }
                    
                    smoothPoints.push(point);
                }
                
                return smoothPoints;
            }
            
            updateStatus(message) {
                document.getElementById('status').textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            }
        }
        
        function clearCanvas() {
            const canvas = document.getElementById('testCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            document.getElementById('status').textContent = 'ç”»å¸ƒå·²æ¸…é™¤ - å‡†å¤‡å¼€å§‹æ–°çš„æµ‹è¯•';
        }
        
        function runAutoTest() {
            const canvas = document.getElementById('testCanvas');
            const ctx = canvas.getContext('2d');
            
            document.getElementById('status').textContent = 'æ­£åœ¨è¿è¡Œè‡ªåŠ¨æµ‹è¯•...';
            
            // æ¨¡æ‹Ÿä¸åŒé€Ÿåº¦çš„ç»˜åˆ¶
            const testStrokes = [
                { name: 'æ…¢é€Ÿç²—çº¿', speed: 5, pressure: 0.8, color: '#ff0000' },
                { name: 'å¿«é€Ÿç»†çº¿', speed: 20, pressure: 0.3, color: '#00ff00' },
                { name: 'å˜é€Ÿçº¿æ¡', speed: 'variable', pressure: 'variable', color: '#0000ff' }
            ];
            
            let currentTest = 0;
            
            function runNextTest() {
                if (currentTest >= testStrokes.length) {
                    document.getElementById('status').textContent = 'è‡ªåŠ¨æµ‹è¯•å®Œæˆ - æ£€æŸ¥ä¸åŒçº¿æ¡çš„ç²—ç»†å˜åŒ–';
                    return;
                }
                
                const test = testStrokes[currentTest];
                document.getElementById('status').textContent = `æ­£åœ¨æµ‹è¯•: ${test.name}`;
                
                ctx.strokeStyle = test.color;
                
                // æ¨¡æ‹Ÿç»˜åˆ¶è½¨è¿¹
                const startX = 50 + currentTest * 280;
                const startY = 100;
                const points = [];
                
                for (let i = 0; i <= 100; i++) {
                    const t = i / 100;
                    const x = startX + t * 200;
                    const y = startY + Math.sin(t * Math.PI * 4) * 50 + currentTest * 150;
                    
                    let pressure, speed;
                    if (test.pressure === 'variable') {
                        pressure = 0.3 + 0.4 * Math.sin(t * Math.PI * 2);
                    } else {
                        pressure = test.pressure;
                    }
                    
                    if (test.speed === 'variable') {
                        speed = 5 + 15 * Math.abs(Math.sin(t * Math.PI * 3));
                    } else {
                        speed = test.speed;
                    }
                    
                    // æ¨¡æ‹ŸåŠ¨æ€çº¿å®½è®¡ç®—
                    const baseSize = 8;
                    const maxWidth = 20;
                    const pressureFactor = 0.5 + (pressure - 0.5) * 0.8;
                    const velocityFactor = Math.max(0.3, 1 - speed * 0.02);
                    const dynamicWidth = Math.max(1, Math.min(maxWidth, baseSize * pressureFactor * velocityFactor));
                    
                    points.push({ x, y, dynamicWidth });
                }
                
                // ç»˜åˆ¶æµ‹è¯•çº¿æ¡
                for (let i = 0; i < points.length - 1; i++) {
                    const current = points[i];
                    const next = points[i + 1];
                    
                    ctx.lineWidth = current.dynamicWidth;
                    ctx.beginPath();
                    ctx.moveTo(current.x, current.y);
                    ctx.lineTo(next.x, next.y);
                    ctx.stroke();
                }
                
                // æ·»åŠ æ ‡ç­¾
                ctx.fillStyle = test.color;
                ctx.font = 'bold 14px Arial';
                ctx.fillText(test.name, startX, startY - 20);
                
                currentTest++;
                setTimeout(runNextTest, 1000);
            }
            
            runNextTest();
        }
        
        // åˆå§‹åŒ–æµ‹è¯•
        window.addEventListener('load', () => {
            const canvas = document.getElementById('testCanvas');
            new DynamicWidthTest(canvas);
        });
    </script>
</body>
</html> 