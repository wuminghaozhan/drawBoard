<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¿ç¬”æ•ˆæœæµ‹è¯• - DrawBoard</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f0f2f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #2c3e50;
            margin: 0 0 10px 0;
        }
        
        .canvas-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .canvas-container {
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 12px;
            background: #f8f9fa;
        }
        
        .canvas-container h3 {
            margin: 0 0 12px 0;
            color: #495057;
            text-align: center;
            font-size: 16px;
        }
        
        .canvas-container canvas {
            display: block;
            width: 100%;
            height: 300px;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            background: white;
            cursor: crosshair;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .control-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        
        .control-group h4 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 14px;
        }
        
        .preset-btn {
            display: block;
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
        
        .preset-btn:hover {
            background: #e9ecef;
        }
        
        .preset-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        
        .info-section {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
            margin-top: 20px;
        }
        
        .info-section h4 {
            margin: 0 0 8px 0;
            color: #1976d2;
        }
        
        .info-section ul {
            margin: 8px 0 0 0;
            padding-left: 20px;
            color: #0d47a1;
        }
        
        .clear-btn {
            padding: 10px 20px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin: 10px;
        }
        
        .clear-btn:hover {
            background: #c82333;
        }
        
        @media (max-width: 768px) {
            .canvas-section {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¨ è¿ç¬”æ•ˆæœä¼˜åŒ–æµ‹è¯•</h1>
            <p>å¯¹æ¯”ä¼˜åŒ–å‰åçš„è¿ç¬”æ•ˆæœå·®å¼‚</p>
        </div>
        
        <div class="canvas-section">
            <div class="canvas-container">
                <h3>ğŸ”¹ ä¼˜åŒ–å‰æ•ˆæœï¼ˆåŸºç¡€çº¿æ¡ï¼‰</h3>
                <canvas id="beforeCanvas" width="500" height="300"></canvas>
                <button class="clear-btn" onclick="clearCanvas('before')">æ¸…ç©º</button>
            </div>
            
            <div class="canvas-container">
                <h3>âœ¨ ä¼˜åŒ–åæ•ˆæœï¼ˆè´å¡å°”å¹³æ»‘ + æŠ—é”¯é½¿ï¼‰</h3>
                <canvas id="afterCanvas" width="500" height="300"></canvas>
                <button class="clear-btn" onclick="clearCanvas('after')">æ¸…ç©º</button>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h4>ğŸ–Œï¸ ç¬”è§¦é¢„è®¾</h4>
                <button class="preset-btn active" onclick="setPreset('brush')">æ¯›ç¬”</button>
                <button class="preset-btn" onclick="setPreset('pen')">é’¢ç¬”</button>
                <button class="preset-btn" onclick="setPreset('calligraphy')">ä¹¦æ³•ç¬”</button>
                <button class="preset-btn" onclick="setPreset('watercolor')">æ°´å½©ç¬”</button>
            </div>
            
            <div class="control-group">
                <h4>ğŸ¯ æµ‹è¯•é¡¹ç›®</h4>
                <button class="preset-btn" onclick="testSlowDraw()">æ…¢é€Ÿç»˜åˆ¶æµ‹è¯•</button>
                <button class="preset-btn" onclick="testFastDraw()">å¿«é€Ÿç»˜åˆ¶æµ‹è¯•</button>
                <button class="preset-btn" onclick="testPressure()">å‹åŠ›å˜åŒ–æµ‹è¯•</button>
                <button class="preset-btn" onclick="testSmoothing()">å¹³æ»‘åº¦æµ‹è¯•</button>
            </div>
        </div>
        
        <div class="info-section">
            <h4>ğŸ“Š ä¼˜åŒ–å†…å®¹å¯¹æ¯”</h4>
            <ul>
                <li><strong>è´å¡å°”æ›²çº¿å¹³æ»‘</strong>ï¼šå·¦ä¾§ä½¿ç”¨ç›´çº¿è¿æ¥ï¼Œå³ä¾§ä½¿ç”¨ä¸‰æ¬¡è´å¡å°”æ›²çº¿</li>
                <li><strong>æ™ºèƒ½å‹åŠ›æ„Ÿåº”</strong>ï¼šå³ä¾§ä½¿ç”¨åŠ æƒç§»åŠ¨å¹³å‡ç®—æ³•ï¼Œå‹åŠ›å“åº”æ›´è‡ªç„¶</li>
                <li><strong>å¤šçº§æŠ—é”¯é½¿</strong>ï¼šå³ä¾§å¯ç”¨é«˜è´¨é‡æŠ—é”¯é½¿ï¼Œçº¿æ¡è¾¹ç¼˜æ›´å¹³æ»‘</li>
                <li><strong>éçº¿æ€§é€Ÿåº¦æ˜ å°„</strong>ï¼šå³ä¾§ä½¿ç”¨åŒæ›²æ­£åˆ‡å‡½æ•°ï¼Œé€Ÿåº¦å˜åŒ–æ›´çº¿æ€§</li>
            </ul>
        </div>
        
        <div class="info-section">
            <h4>ğŸ’¡ æµ‹è¯•å»ºè®®</h4>
            <ul>
                <li>å°è¯•æ…¢é€Ÿç»˜åˆ¶ï¼šè§‚å¯Ÿå‹åŠ›æ„Ÿåº”æ•ˆæœï¼Œçº¿æ¡ç²—ç»†å˜åŒ–</li>
                <li>å°è¯•å¿«é€Ÿç»˜åˆ¶ï¼šå¯¹æ¯”é€Ÿåº¦å“åº”çš„å·®å¼‚</li>
                <li>ç»˜åˆ¶æ›²çº¿ï¼šæ„Ÿå—è´å¡å°”å¹³æ»‘å¸¦æ¥çš„æµç•…æ„Ÿ</li>
                <li>æ”¾å¤§æŸ¥çœ‹ï¼šè§‚å¯ŸæŠ—é”¯é½¿å¯¹çº¿æ¡è´¨é‡çš„æå‡</li>
            </ul>
        </div>
    </div>

    <script>
        // ç®€åŒ–çš„Canvasç»˜åˆ¶ç±»
        class CanvasDrawer {
            constructor(canvas, useOptimization = false) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.useOptimization = useOptimization;
                this.isDrawing = false;
                this.currentPath = [];
                this.paths = [];
                
                // é…ç½®
                this.config = {
                    enablePressure: true,
                    enableVelocity: true,
                    pressureSensitivity: 1.0,
                    velocitySensitivity: 0.8,
                    minLineWidth: 2,
                    maxLineWidth: 30,
                    smoothing: 0.4
                };
                
                this.setupEvents();
                this.setupCanvas();
            }
            
            setupCanvas() {
                if (this.useOptimization) {
                    // ä¼˜åŒ–åï¼šé«˜è´¨é‡æŠ—é”¯é½¿
                    this.ctx.imageSmoothingEnabled = true;
                    this.ctx.imageSmoothingQuality = 'high';
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                } else {
                    // ä¼˜åŒ–å‰ï¼šåŸºç¡€è®¾ç½®
                    this.ctx.imageSmoothingEnabled = false;
                    this.ctx.lineCap = 'butt';
                    this.ctx.lineJoin = 'miter';
                }
            }
            
            setupEvents() {
                this.canvas.addEventListener('mousedown', (e) => this.startDraw(e));
                this.canvas.addEventListener('mousemove', (e) => this.draw(e));
                this.canvas.addEventListener('mouseup', () => this.endDraw());
                this.canvas.addEventListener('mouseleave', () => this.endDraw());
            }
            
            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY,
                    timestamp: Date.now()
                };
            }
            
            startDraw(e) {
                this.isDrawing = true;
                const pos = this.getMousePos(e);
                this.currentPath = [pos];
            }
            
            draw(e) {
                if (!this.isDrawing) return;
                
                const pos = this.getMousePos(e);
                this.currentPath.push(pos);
                
                this.redraw();
            }
            
            endDraw() {
                if (!this.isDrawing) return;
                
                this.isDrawing = false;
                if (this.currentPath.length > 1) {
                    this.paths.push([...this.currentPath]);
                }
                this.currentPath = [];
            }
            
            redraw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ç»˜åˆ¶å·²å®Œæˆçš„è·¯å¾„
                this.paths.forEach(path => this.drawPath(path));
                
                // ç»˜åˆ¶å½“å‰è·¯å¾„
                if (this.currentPath.length > 1) {
                    this.drawPath(this.currentPath);
                }
            }
            
            drawPath(points) {
                if (points.length < 2) return;
                
                const strokePoints = this.calculateStrokeParameters(points);
                
                if (this.useOptimization && strokePoints.length > 3) {
                    this.drawBezierStroke(strokePoints);
                } else {
                    this.drawLinearStroke(strokePoints);
                }
            }
            
            calculateStrokeParameters(points) {
                const strokePoints = [];
                
                for (let i = 0; i < points.length; i++) {
                    const point = {...points[i]};
                    
                    // è®¡ç®—å‹åŠ›
                    if (this.config.enablePressure) {
                        point.pressure = this.calculatePressure(points, i);
                    } else {
                        point.pressure = 0.5;
                    }
                    
                    // è®¡ç®—é€Ÿåº¦
                    if (this.config.enableVelocity && i > 0) {
                        point.velocity = this.calculateVelocity(points[i-1], points[i]);
                    } else {
                        point.velocity = 0.5;
                    }
                    
                    strokePoints.push(point);
                }
                
                return strokePoints;
            }
            
            calculatePressure(points, index) {
                const windowSize = this.useOptimization ? 4 : 2;
                const start = Math.max(0, index - windowSize);
                const end = Math.min(points.length - 1, index + windowSize);
                
                if (end <= start) return 0.5;
                
                let totalDistance = 0;
                let count = 0;
                
                if (this.useOptimization) {
                    // ä¼˜åŒ–ç®—æ³•ï¼šåŠ æƒç§»åŠ¨å¹³å‡
                    let weightedDistance = 0;
                    let totalWeight = 0;
                    
                    for (let i = start; i < end; i++) {
                        if (i > 0) {
                            const dx = points[i].x - points[i-1].x;
                            const dy = points[i].y - points[i-1].y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            const distanceFromCurrent = Math.abs(i - index);
                            const weight = Math.exp(-distanceFromCurrent * 0.5);
                            
                            weightedDistance += distance * weight;
                            totalWeight += weight;
                        }
                    }
                    
                    if (totalWeight === 0) return 0.5;
                    
                    const avgDistance = weightedDistance / totalWeight;
                    const pressure = Math.exp(-avgDistance / 15);
                    return Math.min(1, Math.max(0, pressure * this.config.pressureSensitivity));
                } else {
                    // åŸºç¡€ç®—æ³•ï¼šç®€å•å¹³å‡
                    for (let i = start; i < end; i++) {
                        if (i > 0) {
                            const dx = points[i].x - points[i-1].x;
                            const dy = points[i].y - points[i-1].y;
                            totalDistance += Math.sqrt(dx * dx + dy * dy);
                            count++;
                        }
                    }
                    
                    if (count === 0) return 0.5;
                    
                    const avgDistance = totalDistance / count;
                    const pressure = Math.exp(-avgDistance / 20);
                    return Math.min(1, Math.max(0, pressure * this.config.pressureSensitivity));
                }
            }
            
            calculateVelocity(p1, p2) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (this.useOptimization) {
                    // ä¼˜åŒ–ç®—æ³•ï¼šéçº¿æ€§æ˜ å°„
                    return Math.tanh(distance / 12);
                } else {
                    // åŸºç¡€ç®—æ³•ï¼šçº¿æ€§æ˜ å°„
                    return Math.min(1, distance / 15);
                }
            }
            
            drawBezierStroke(points) {
                // è´å¡å°”æ›²çº¿å¹³æ»‘ç»˜åˆ¶
                this.ctx.beginPath();
                this.ctx.moveTo(points[0].x, points[0].y);
                
                for (let i = 1; i < points.length - 1; i++) {
                    const current = points[i];
                    const next = points[i + 1];
                    
                    this.applyStrokeEffect(current);
                    
                    const cpx = (current.x + next.x) / 2;
                    const cpy = (current.y + next.y) / 2;
                    
                    this.ctx.quadraticCurveTo(current.x, current.y, cpx, cpy);
                }
                
                if (points.length > 1) {
                    const lastPoint = points[points.length - 1];
                    this.ctx.lineTo(lastPoint.x, lastPoint.y);
                }
                
                this.ctx.stroke();
            }
            
            drawLinearStroke(points) {
                // ç›´çº¿è¿æ¥ç»˜åˆ¶
                for (let i = 0; i < points.length - 1; i++) {
                    const current = points[i];
                    const next = points[i + 1];
                    
                    this.applyStrokeEffect(current);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(current.x, current.y);
                    this.ctx.lineTo(next.x, next.y);
                    this.ctx.stroke();
                }
            }
            
            applyStrokeEffect(point) {
                // è®¡ç®—åŠ¨æ€çº¿å®½
                let width = this.config.minLineWidth;
                
                if (point.pressure !== undefined) {
                    width += (this.config.maxLineWidth - this.config.minLineWidth) * point.pressure;
                }
                
                if (point.velocity !== undefined) {
                    const velocityFactor = 1 - point.velocity * this.config.velocitySensitivity * 0.8;
                    width *= Math.max(0.3, velocityFactor);
                }
                
                this.ctx.lineWidth = Math.max(this.config.minLineWidth, 
                                            Math.min(this.config.maxLineWidth, width));
                
                // è®¡ç®—åŠ¨æ€é€æ˜åº¦
                let alpha = 1.0;
                if (point.pressure !== undefined) {
                    alpha *= 0.6 + point.pressure * 0.4;
                }
                
                this.ctx.globalAlpha = Math.max(0.2, Math.min(1.0, alpha));
                this.ctx.strokeStyle = '#2c3e50';
            }
            
            updateConfig(config) {
                this.config = {...this.config, ...config};
                this.redraw();
            }
            
            clear() {
                this.paths = [];
                this.currentPath = [];
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
        }
        
        // é¢„è®¾é…ç½®
        const presets = {
            brush: {
                enablePressure: true,
                enableVelocity: true,
                pressureSensitivity: 1.0,
                velocitySensitivity: 0.8,
                minLineWidth: 2,
                maxLineWidth: 30,
                smoothing: 0.4
            },
            pen: {
                enablePressure: true,
                enableVelocity: true,
                pressureSensitivity: 0.9,
                velocitySensitivity: 0.3,
                minLineWidth: 0.5,
                maxLineWidth: 8,
                smoothing: 0.1
            },
            calligraphy: {
                enablePressure: true,
                enableVelocity: true,
                pressureSensitivity: 1.0,
                velocitySensitivity: 0.7,
                minLineWidth: 1,
                maxLineWidth: 25,
                smoothing: 0.3
            },
            watercolor: {
                enablePressure: true,
                enableVelocity: true,
                pressureSensitivity: 0.9,
                velocitySensitivity: 1.0,
                minLineWidth: 3,
                maxLineWidth: 20,
                smoothing: 0.5
            }
        };
        
        // åˆå§‹åŒ–ç”»å¸ƒ
        const beforeCanvas = new CanvasDrawer(document.getElementById('beforeCanvas'), false);
        const afterCanvas = new CanvasDrawer(document.getElementById('afterCanvas'), true);
        
        // å·¥å…·å‡½æ•°
        function setPreset(presetName) {
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // åº”ç”¨é¢„è®¾
            const config = presets[presetName];
            beforeCanvas.updateConfig(config);
            afterCanvas.updateConfig(config);
        }
        
        function clearCanvas(type) {
            if (type === 'before') {
                beforeCanvas.clear();
            } else {
                afterCanvas.clear();
            }
        }
        
        function testSlowDraw() {
            alert('è¯·åœ¨ä¸¤ä¸ªç”»å¸ƒä¸Šè¿›è¡Œæ…¢é€Ÿç»˜åˆ¶ï¼Œè§‚å¯Ÿå‹åŠ›æ„Ÿåº”æ•ˆæœçš„å·®å¼‚');
        }
        
        function testFastDraw() {
            alert('è¯·åœ¨ä¸¤ä¸ªç”»å¸ƒä¸Šè¿›è¡Œå¿«é€Ÿç»˜åˆ¶ï¼Œå¯¹æ¯”é€Ÿåº¦å“åº”çš„å·®å¼‚');
        }
        
        function testPressure() {
            alert('è¯·ç»˜åˆ¶æ—¶æ”¹å˜æŒ‰å‹åŠ›åº¦ï¼ˆé€šè¿‡ç»˜åˆ¶å¯†åº¦æ¨¡æ‹Ÿï¼‰ï¼Œè§‚å¯Ÿçº¿æ¡ç²—ç»†å˜åŒ–');
        }
        
        function testSmoothing() {
            alert('è¯·ç»˜åˆ¶æ›²çº¿ï¼Œæ„Ÿå—å³ä¾§è´å¡å°”å¹³æ»‘å¸¦æ¥çš„æµç•…æ„Ÿ');
        }
        
        // åˆå§‹åŒ–æ¯›ç¬”é¢„è®¾
        const brushConfig = presets.brush;
        beforeCanvas.updateConfig(brushConfig);
        afterCanvas.updateConfig(brushConfig);
    </script>
</body>
</html> 